\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{french}


\title{Projet 3}
\author{Eliot Peeters}
\author{Constantin van Ypersele 71091800}



\usepackage{natbib}
\usepackage{graphicx}
\usepackage{fourier}
\begin{document}

\maketitle

\section{Introduction}
Les nombres premiers sont des nombres définis comme ayant pour unique diviseur le chiffre 1 et le nombre lui-même. Connus depuis bien longtemps, ils ne cessent de fasciner les mathématiciens. Avec l'apparition d'internet, ils ont été et sont toujours fortement employés dans les systèmes de cryptage.

\section{Choix de conceptions}

\subsection{Optimisation du code de base}
Afin d'augmenter les performances des fonctions de bases, à savoir $isprime$ et $primedivs$, le principe de mémoïsation a été choisi. Chaque nombre premier trouvé sera stocké dans une seule et même structure de type $Repertoire\_t$ passée en argument à ces fonctions. Cette structure contient une variable $nbre\_elem$ qui compte le nombre de nombre premier contenu dans la varible $liste$. \\ \\
\danger La taille de la mémoire $liste$ est alloué dynamiquement en ajoutant la mémoire strictement nécessaire pour ajouter chaque élément. Une alternative aurait été de doubler la mémoire chaque fois que celle-ci est remplie afin d'éviter de devoir la modifier à chaque ajout. Après plusieurs tests, il est apparu que les deux choix étaient identiques d'un point de vue performances. La 1e option a donc été retenue afin de minimiser le gaspillage de mémoire. 

\subsection{Multhithreading}
Pour implémenter un programme concurrent, un système composé d'un double producer-consummer de type $FIFO$ a été choisi. D'une part un premier thread ($lecteur\_th$) lit le fichier d'entré et place les nombres trouvés dans une structure de type $Entrepot\_th$. Ensuite, les N threads de calculs ($calcul\_th$) récupèrent ces nombres, calculent leurs diviseurs premiers et placent à leur tour leur résultat dans une deuxième structure $Entepot\_t$. Enfin, un thread d'écriture ($imprimeur\_th$) récupère et écrit ces résultats dans le fichier de sortie. Le fonctionnement des différentes fonctions est décrit plus en détail dans les sous-sections ci-dessous.\\ 
\\ \danger Lorsque l'on crée un thread, il faut lui donner \underline{une} fonction (sur laquelle il s'exécutera) et \underline{un} seul argument. Étant donné que les fonctions nécessitent plus d'un argument, des structures propres à chaque fonctions ont été créés. Celles-ci contiennent tous les arguments nécessaires.

\subsubsection{Lecture}
La lecture du fichier se fait via la fonction $lecture$ qui prend comme argument une structure de type $Lecteur\_Th$. Cette fonction joue le rôle du premier producteur. Son fonctionnement est le suivant: tant que le thread n'est pas arrivé à la fin du fichier, il lit chaque ligne et la transforme en un $unsigned long long$. Ensuite, grâce à une sémaphore, il attend une place dans la variable $tableau$ (qui est de taille $2N$ où $N$ est le nombre de thread de calcul).Lorsqu'une place est disponible, il protège l'accès au tableau grâce à un mutex, ajoute le nombre et fait appel à la fonction $sem\_post$ pour prévenir qu'un élément a été ajouté dans le premier tableau.
Le comportement du thread lorsqu'il arrive à la fin du fichier est expliqué dans la partie communication entre thread.

\subsubsection{Calcul}
La fonction $calcul$ est la fonction sur laquelle les $N$ threads de calculs seront exécutés. Son fonctionnement est le suivant: tant que le $lecteur$ n'a pas fini de lire le fichier ou qu'il reste des éléments dans le premier tableau,le thread de calcul attend grâce à une première sémaphore qu'un élément soit déposé dans le tableau $tabin$. Ensuite il en protège l'accès, prend l'élément, met à jour les informations du tableau (nombre d'éléments et index de saisie) puis prévient le lecteur qu'une place a été libérée. Il calcule ensuite la liste des diviseurs premier de son nombre en appelant la fonction $primedivs$. Jusqu'ici la fonction s'est comportée comme le premier $consummer$. Il est temps pour elle d'endosser le rôle du second $producer$. À nouveau, la fonction attend grâce à une sémaphore qu'une place soit disponible dans le second tableau ($tabout$), le protège, place son résultat, met à jour les informations et prévient le thread d'écriture qu'un résultat a été ajouté.\\
\\ \danger
Cette fonction est la partie critique du programme: c'est elle qui demande le plus de temps. Pour cette raison, il faut donner la priorité aux $N$ threads de calculs et minimiser leur temps d'inactivité. Ainsi, la taille des tableaux stockant les structures contenant les résultats est de $2*N$. Cette marge permet d'éviter le cas où plusieurs threads devraient attendre que le lecteur remplisse le premier tableau ou que des places soient libérées dans le second tableau.

\subsubsection{Écriture}
L'écriture des résultats dans le fichier de sortie est assuré par un thread qui exécute la fonction $écriture$. Cette fonction 


\bibliographystyle{plain}
\bibliography{references}
\end{document}