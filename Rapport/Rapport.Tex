\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{french}


\title{Projet 3}
\author{Eliot Peeters}
\author{Constantin van Ypersele 71091800}



\usepackage{natbib}
\usepackage{graphicx}
\usepackage{fourier}
\begin{document}

\maketitle

\section{Introduction}
Les nombres premiers sont des nombres définis comme ayant pour unique diviseur le chiffre 1 et le nombre lui-même. Connus depuis bien longtemps, ils ne cessent de fasciner les mathématiciens. Avec l'apparition d'internet, ils ont été et sont toujours fortement employés dans les systèmes de cryptage.

\section{Choix de conceptions}

\subsection{Optimisation du code de base}
Afin d'augmenter les performances des fonctions de bases, à savoir $isprime$ et $primedivs$, le principe de mémoïsation a été choisi. Chaque nombre premier trouvé sera stocké dans une seule et même structure de type $Repertoire\_t$ passée en argument à ces fonctions. Cette structure contient une variable $nbre\_elem$ qui compte le nombre de nombre premier contenu dans la varible $liste$. \\ \\
\danger La taille de la mémoire $liste$ est alloué dynamiquement en ajoutant la mémoire strictement nécessaire pour ajouter chaque élément. Une alternative aurait été de doubler la mémoire chaque fois que celle-ci est remplie afin d'éviter de devoir la modifier à chaque ajout. Après plusieurs tests, il est apparu que les deux choix étaient identiques d'un point de vue performances. La 1e option a donc été retenue afin de minimiser le gaspillage de mémoire. 

\subsection{Multhithreading}
Pour implémenter un programme concurrent, un système composé d'un double producer-consummer de type $FIFO$ a été choisi. D'une part un premier thread lit le fichier d'entré et place les nombres trouvés dans une structure de type $Entrepot\_th$. Ensuite, les N threads de calculs récupèrent ces nombres, calculent leurs diviseurs premiers et placent à leur tour leur résultat dans une deuxième structure $Entepot\_t$. Enfin, un thread d'écriture récupère et écrit ces résultats dans le fichier de sortie. Le fonctionnement des différentes fonctions est décrit plus en détail dans les sous-sections ci-dessous.\\ \\
\danger Lorsque l'on crée un thread, il faut lui donner une fonction (sur laquelle il s'exécutera) et \underline{un} seul argument. Étant donné que les fonctions nécessitent plus d'un argument, des structures spécifiques à chaque fonctions ont été créés. Celles-ci contiennent tous les arguments nécessaires.

\subsubsection{Lecture}
La lecture du fichier se fait via la fonction $lecture$ qui prend comme argument une structure de type $Lecteur\_Th$. Cette fonction joue le rôle du premier producteur. Son fonctionnement est le suivant: tant que le thread n'est pas arrivé à la fin du fichier, il lit chaque ligne et la transforme en un $unsigned long long$. Ensuite, grâce à une sémaphore, il attend une place dans la variable $tableau$ (qui est de taille $2N$ où $N$ est le nombre de thread de calcul).Lorsqu'une place est disponible, il protège l'accès au tableau grâce à un mutex, ajoute le nombre et fait appel à la fonction $sem\_post$ pour prévenir qu'un élément a été ajouté dans le premier tableau.
Le comportement du thread lorsqu'il arrive à la fin du fichier est expliqué dans la partie communication entre thread.

\bibliographystyle{plain}
\bibliography{references}
\end{document}
