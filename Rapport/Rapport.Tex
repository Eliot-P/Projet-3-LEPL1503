\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{french}


\title{Projet 3}
\author{Eliot Peeters}
\author{Constantin van Ypersele 71091800}



\usepackage{natbib}
\usepackage{graphicx}
\begin{document}

\maketitle

\section{Introduction}
Les nombres premiers sont des nombres définis comme ayant pour unique diviseur le chiffre 1 et le nombre lui-même. Connus depuis bien longtemps, ils ne cessent de fasciner les mathématiciens. Avec l'apparition d'internet, ils ont été et sont toujours fortement employés dans les systèmes de cryptage.

\section{Choix de conceptions}
Afin d'implémenter un algorithme efficace, différents choix se présentèrent. Il a été décidé d'utiliser le principe de $mémoïsation$: chaque nombre premier calculé sera stocké dans une structure (nommée $repertoire$) afin d'éviter de devoir calculer plusieurs fois le même nombre premier. Cette même structure sera passée comme argument de la fonction $isprime$ et $primedivs$ afin de considérablement améliorer les performances du programme. Il est important de remarquer que la variable $liste$ de la structure est un tableau dont la taille est celle du nombre d'éléments qu'elle contient. Á chaque nouveau nombre premier, on réaloue dynamiquement de la mémoire afin de pouvoir le stocker. Une alternative aurait été d'alouer une certaine mémoire à la variable et d'en doubler sa taille chaque fois que la capacité maximale est atteinte mais nous avons remarqué après des tests que les deux alternatives étaient totalement identiques d'un point de vue des performances. La 1e solution a donc été retenue afin de ne pas utiliser inutilement de la mémoire. \\
Ensuite, un double système de $producer - consumer$ a été employé pour implémenter la partie multithreads du programme. Le but étant de maximiser le temps accordé aux threads de calcul (car ce sont eux qui effectuent la partie la plus lente du programme, à savoir calculer les diviseurs premiers de chaque nombre). Concrètement, un premier thread ($lecteur$) est initialisé avec la fonction $lecture$ qui, comme son nom l'indique, est chargée de la lecture du fichier d'entrée. Ce thread est également initialisé avec une structure $lect$ qui contient tout les arguments nécessaires. Cette fonction est le premier $producer$. Elle lit chaque ligne du fichier, la caste en un $unsigned$ $long$ $long$ et place le résultat dans le premier $buffer$ ($tableau1$). Ce $buffer$  est une structure ($entrepot$) dont les noms des variables sont assez explicites pour ne pas être détaillés. La taille du $buffer$  dépend directement du nombre $N$ de thread de calcul utilisés. Il a été décidé que cette taille serait de $\frac{3N}{2}$. Nous avons prévu une marge pour éviter le cas où plusieurs threads de calcul devraient attendre d'avoir de nouveaux nombres à traiter. 
\\
Arrivent ensuite les threads

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
